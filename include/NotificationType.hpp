// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from com_verifone_commerce_payment.djinni

#pragma once

#include <functional>
#include <string>

namespace verifone_sdk {

enum class NotificationType : int {
    WAITING_FOR_CARD,
    WAITING_FOR_CUSTOMER_APP_SELECTION,
    WAITING_FOR_ACCOUNT,
    WAITING_FOR_PIN,
    WAITING_FOR_TIP,
    WAITING_FOR_SURCHARGE,
    WAITING_FOR_CURRENCY,
    DEVICE_TAMPERED,
    WAITING_FOR_CASH,
    WAITING_FOR_SIGNATURE,
    /** Provide transaction outcome earlier than final transaction response */
    TRANSACTION_OUTCOME,
    CARD_PRESENTED,
    CARD_PROCESSING,
    REMOVE_CARD,
    CARD_REMOVED,
    /** The communication with the host has started and is now in progress. */
    HOST_STARTING,
    /** A stage during EMV processing */
    PERFORMING_RISK_MANAGEMENT,
    HOST_RESPONSE_RECEIVED,
    PRINTING_CASHIER_RECEIPT,
    PRINTING_CUSTOMER_RECEIPT,
    /** The payment application has requested some input from the customer and is currently waiting for their response. */
    WAITING_FOR_CUSTOMER_INPUT,
    /** The card has expired and the customer is prompted to retry. */
    CARD_EXPIRED_RETRY,
    /** The card presentation method must fallback to a different method and the customer is prompted to retry. */
    CARD_FALLBACK_RETRY,
    /** The card was unable to be read over NFC and the customer is prompted to retry. */
    CARD_BAD_READ_NFC_RETRY,
    /** The card was unable to be read when swiped and the customer is prompted to retry. */
    CARD_BAD_READ_SWIPE_RETRY,
    /** The terminal is entering maintenance mode and will not be available until maintenance ends. */
    BEGIN_MAINTENANCE,
    /** The terminal has finished maintenance and is now available for use. */
    END_MAINTENANCE,
    /**
     * The connection to the device was lost, and automatic connection recovery is in progress.
     * A connection indicator or something similar can be altered in response to this event,
     * but no retry or automatic error handling should happen. A different event will be fired with
     * a status code of DEVICE_CONNECTION_LOST if the connection cannot be recovered. If the
     * connection is automatically recovered, a notification with type CONNECTED will be sent.
     */
    CONNECTION_LOST,
    /** A terminal is connected. */
    CONNECTED,
    /** A terminal is shutdown. */
    SHUTDOWN,
    /** Some other type besides those listed above. Simply present the event message in this case. */
    OTHER,
    /** For internal/legacy POS support only */
    INTERNAL,
    /** A payment terminal requests payment of a transaction. */
    SALE_WAKE_UP,
    /** A payment terminal performs an automatic administrative process */
    SALE_ADMIN,
};

constexpr std::string_view toString(const NotificationType& arg) {
    switch(arg) {
        case NotificationType::WAITING_FOR_CARD: return "WAITING_FOR_CARD";
        case NotificationType::WAITING_FOR_CUSTOMER_APP_SELECTION: return "WAITING_FOR_CUSTOMER_APP_SELECTION";
        case NotificationType::WAITING_FOR_ACCOUNT: return "WAITING_FOR_ACCOUNT";
        case NotificationType::WAITING_FOR_PIN: return "WAITING_FOR_PIN";
        case NotificationType::WAITING_FOR_TIP: return "WAITING_FOR_TIP";
        case NotificationType::WAITING_FOR_SURCHARGE: return "WAITING_FOR_SURCHARGE";
        case NotificationType::WAITING_FOR_CURRENCY: return "WAITING_FOR_CURRENCY";
        case NotificationType::DEVICE_TAMPERED: return "DEVICE_TAMPERED";
        case NotificationType::WAITING_FOR_CASH: return "WAITING_FOR_CASH";
        case NotificationType::WAITING_FOR_SIGNATURE: return "WAITING_FOR_SIGNATURE";
        case NotificationType::TRANSACTION_OUTCOME: return "TRANSACTION_OUTCOME";
        case NotificationType::CARD_PRESENTED: return "CARD_PRESENTED";
        case NotificationType::CARD_PROCESSING: return "CARD_PROCESSING";
        case NotificationType::REMOVE_CARD: return "REMOVE_CARD";
        case NotificationType::CARD_REMOVED: return "CARD_REMOVED";
        case NotificationType::HOST_STARTING: return "HOST_STARTING";
        case NotificationType::PERFORMING_RISK_MANAGEMENT: return "PERFORMING_RISK_MANAGEMENT";
        case NotificationType::HOST_RESPONSE_RECEIVED: return "HOST_RESPONSE_RECEIVED";
        case NotificationType::PRINTING_CASHIER_RECEIPT: return "PRINTING_CASHIER_RECEIPT";
        case NotificationType::PRINTING_CUSTOMER_RECEIPT: return "PRINTING_CUSTOMER_RECEIPT";
        case NotificationType::WAITING_FOR_CUSTOMER_INPUT: return "WAITING_FOR_CUSTOMER_INPUT";
        case NotificationType::CARD_EXPIRED_RETRY: return "CARD_EXPIRED_RETRY";
        case NotificationType::CARD_FALLBACK_RETRY: return "CARD_FALLBACK_RETRY";
        case NotificationType::CARD_BAD_READ_NFC_RETRY: return "CARD_BAD_READ_NFC_RETRY";
        case NotificationType::CARD_BAD_READ_SWIPE_RETRY: return "CARD_BAD_READ_SWIPE_RETRY";
        case NotificationType::BEGIN_MAINTENANCE: return "BEGIN_MAINTENANCE";
        case NotificationType::END_MAINTENANCE: return "END_MAINTENANCE";
        case NotificationType::CONNECTION_LOST: return "CONNECTION_LOST";
        case NotificationType::CONNECTED: return "CONNECTED";
        case NotificationType::SHUTDOWN: return "SHUTDOWN";
        case NotificationType::OTHER: return "OTHER";
        case NotificationType::INTERNAL: return "INTERNAL";
        case NotificationType::SALE_WAKE_UP: return "SALE_WAKE_UP";
        case NotificationType::SALE_ADMIN: return "SALE_ADMIN";
        default: return "NotificationType enum value not supported";
    }
}

}  // namespace verifone_sdk

namespace std {

template <>
struct hash<::verifone_sdk::NotificationType> {
    size_t operator()(::verifone_sdk::NotificationType type) const {
        return std::hash<int>()(static_cast<int>(type));
    }
};

}  // namespace std
