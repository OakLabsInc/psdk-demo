// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from EncryptionRequest.djinni

#pragma once

#include <functional>
#include <string>

namespace verifone_sdk {

enum class EncryptionOptions : unsigned {
    /** Default value. There is no "all" option because some options are incompatible. */
    NONE = 0,
    /**
     *Encryption Options bit mapped flags passed as hex strings:
     *Data padding with 0x00: XX XX XX XX 00 00 00 00
     */
    DATA_PADDING_00 = 1 << 0,
    /**Data padding with 0xff: XX XX XX XX ff ff ff ff */
    DATA_PADDING_FF = 1 << 1,
    /**Truncate PAN (TLV tag 5A): 123456789FFFF =&gt; 123456789F */
    TRUNCATE_PAN = 1 << 2,
    /**Add empty tags (with length 0) to result */
    ADD_EMPTY_TAGS = 1 << 3,
    /**Truncate values if data exceeds the fixed length */
    TRUNCATE = 1 << 4,
    /**
     *Use the associated value only, without tag or length information.  Not allowed if requesting
     *more than one tag and one or more tags are requested as variable length.
     */
    VALUE_ONLY = 1 << 5,
    /**
     *Format MSR Track 2 (TLV tag 57) according to the EMV Track 2 Equivalent Data spec.
     *For CT and CTLS, this has no effect as they are already in the expected EMV format.
     *When not used with MSR, Track2 will contain start and end sentinels and LRC.
     */
    TRACK2_EMV = 1 << 6,
    /**
     *Format CVV as an ASCII string with no padding and no null terminator.
     *When not used, CVV will be in BCD, with trailing F for odd length values
     */
    CVV_ASCII = 1 << 7,
    /**
     *Format PAN as an ASCII string with no padding and no null terminator.
     *When not used, PAN will be in BCD, with trailing F for odd length values
     */
    PAN_ASCII = 1 << 8,
    /**
     *Format Track 2 as an ASCII string with no padding and no null terminator.
     *When not used, Track2 will be in BCD, with trailing F for odd length values
     */
    TRACK2_ASCII = 1 << 9,
    /**Format Expiry Date (TLV tag 5F24) as an ASCII string with no padding */
    EXPIRY_ASCII = 1 << 10,
    /**
     *Format Track 2 as an ASCII string according to MSR spec with start ';' and end '?' sentinels
     *but with no LRC or padding
     */
    TRACK2_ASCII_MSR = 1 << 11,
    /**
     *Format Track1 equivalent data (TLV tag 56) according the EMV Track 1 Equivalent Data spec.
     *For CT and CTLS, this has no effect as they are already in the expected EMV format.
     *When not used with MSR, Track1 will contain start and end sentinels and LRC.
     */
    TRACK1_EMV = 1 << 12,
};
constexpr EncryptionOptions operator|(EncryptionOptions lhs, EncryptionOptions rhs) noexcept {
    return static_cast<EncryptionOptions>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs));
}
inline EncryptionOptions& operator|=(EncryptionOptions& lhs, EncryptionOptions rhs) noexcept {
    return lhs = lhs | rhs;
}
constexpr EncryptionOptions operator&(EncryptionOptions lhs, EncryptionOptions rhs) noexcept {
    return static_cast<EncryptionOptions>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs));
}
inline EncryptionOptions& operator&=(EncryptionOptions& lhs, EncryptionOptions rhs) noexcept {
    return lhs = lhs & rhs;
}
constexpr EncryptionOptions operator^(EncryptionOptions lhs, EncryptionOptions rhs) noexcept {
    return static_cast<EncryptionOptions>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs));
}
inline EncryptionOptions& operator^=(EncryptionOptions& lhs, EncryptionOptions rhs) noexcept {
    return lhs = lhs ^ rhs;
}
constexpr EncryptionOptions operator~(EncryptionOptions x) noexcept {
    return static_cast<EncryptionOptions>(~static_cast<unsigned>(x));
}

constexpr std::string_view toString(const EncryptionOptions& arg) {
    switch(arg) {
        case EncryptionOptions::DATA_PADDING_00: return "DATA_PADDING_00";
        case EncryptionOptions::DATA_PADDING_FF: return "DATA_PADDING_FF";
        case EncryptionOptions::TRUNCATE_PAN: return "TRUNCATE_PAN";
        case EncryptionOptions::ADD_EMPTY_TAGS: return "ADD_EMPTY_TAGS";
        case EncryptionOptions::TRUNCATE: return "TRUNCATE";
        case EncryptionOptions::VALUE_ONLY: return "VALUE_ONLY";
        case EncryptionOptions::TRACK2_EMV: return "TRACK2_EMV";
        case EncryptionOptions::CVV_ASCII: return "CVV_ASCII";
        case EncryptionOptions::PAN_ASCII: return "PAN_ASCII";
        case EncryptionOptions::TRACK2_ASCII: return "TRACK2_ASCII";
        case EncryptionOptions::EXPIRY_ASCII: return "EXPIRY_ASCII";
        case EncryptionOptions::TRACK2_ASCII_MSR: return "TRACK2_ASCII_MSR";
        case EncryptionOptions::TRACK1_EMV: return "TRACK1_EMV";
        default: return "EncryptionOptions enum value not supported";
    }
}

}  // namespace verifone_sdk

namespace std {

template <>
struct hash<::verifone_sdk::EncryptionOptions> {
    size_t operator()(::verifone_sdk::EncryptionOptions type) const {
        return std::hash<unsigned>()(static_cast<unsigned>(type));
    }
};

}  // namespace std
